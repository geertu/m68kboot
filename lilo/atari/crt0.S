/* crt0.S -- Startup code for TOS part of Atari LILO booter
 *
 * Copyright (C) 1997 Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de>
 *
 * This program is free software.  You can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation: either version 2 or
 * (at your option) any later version.
 * 
 * $Id: crt0.S,v 1.1 1997-08-12 15:27:08 rnhodek Exp $
 * 
 * $Log: crt0.S,v $
 * Revision 1.1  1997-08-12 15:27:08  rnhodek
 * Import of Amiga and newly written Atari lilo sources, with many mods
 * to separate out common parts.
 *
 * 
 */

#include "bootparam.h"

#define _sysbase	0x4f2
		
/*
 * Globally visible variables declared by crtinit.c
 */
	
	.bss
	.globl	__app
	.globl	__base
	.globl	__heapbase	| picked up from user or from heapbase.c
	.globl	__stksize	| long, declared by user or in stksiz.c
	.globl	__PgmSize
	.globl	___DEFAULT_BUFSIZ__
	.globl	__split_mem
	
	.comm	__app, 2
	.comm	__base, 4
	.comm	__PgmSize, 4
	.comm	___DEFAULT_BUFSIZ__, 4
	.comm	__split_mem, 2

#define BUFSIZ	1024
	
/*
 * externs to pull ident strings of all used libraries into the
 * executable; if a library is not used, then the extern is
 * satisfied by a dummy in the library
 */

	.globl	___Ident_libg
	.globl	___Ident_curses
	.globl	___Ident_widget
	.globl	___Ident_gem
	.globl	___Ident_pml
	.globl	___Ident_gnulib

/* Dummy argument array and environment */

	.data
dummy_env:
	.byte	0,0
arg_array:
	.long	arg0
	.long	0
arg0:
	.asciz	"loader.ttp"
	
/* own data */

halt_text:
	.ascii	"LILO loader exited -- system halted."
	.byte	13,10,0
	
/*
 * used globals
 */

	.globl	_ExitAction
	.globl	_CurrentFloppy
	.globl	_exit
	
/*
 * Code
 */

	.text
	.even
	.globl	__start
__start:

/* Output a 'b' to indicate the TOS prg part has started up */
	moveq	#'b',d0
	jbsr	putc

	/* First relocate ourselves */
	
	lea	pc@(__start),a0		/* a0: program base addr */
	lea	a0@(-TOSPRGHDR_SIZE),a6	/* a6: pointer to header */
	movl	a0,a2
	movl	a0,d0			/* d0: reloc offset */
	addl	a6@(PRGHDR_TLEN),a2
	addl	a6@(PRGHDR_DLEN),a2
	addl	a6@(PRGHDR_SLEN),a2	/* a2: current reloc entry */
	tstl	a2@
	jbeq	end_reloc		/* first long is zero: no relocs */
	movq	#0,d1			/* clear d1 for sign extends */
	addl	a2@+,a0			/* go to first reloc addr */
do_reloc:	
	addl	d0,a0@			/* relocate (a0) */
fetch_next_reloc:
	movb	a2@+,d1			/* fetch offset to next reloc */
	jbeq	end_reloc		/* zero byte means end */
	cmpb	#1,d1
	jbne	1f
	addw	#0xfe,a0		/* one byte means add 254 and next */
	jbra	fetch_next_reloc
1:	addw	d1,a0
	jbra	do_reloc
end_reloc:
			
/* Output a 'o' to indicate the TOS prg is relocated */
	moveq	#'o',d0
	jbsr	putc

	/* save value of d7 (old contents of _bootdev) */
	andl	#0xffff,d7
	movl	d7,_CurrentFloppy
	/* set up desired size of loader stack */
	movl	#4096,__stksize

	/* Since we're not started by TOS, we've got no real basepage.
	 * However, we need __base for Mshrink()ing our memory. The base
	 * address of our memory block is the start address, minus the size of
	 * the TOS program header, minus 512 bytes where the map sector was
	 * stored.
	 */
	movl	#__start-TOSPRGHDR_SIZE-512,a5
	movl	a5,__base

	/* calculate final program size and do the Mshrink() */
	movl	a6@(PRGHDR_TLEN),d7
	addl	a6@(PRGHDR_DLEN),d7
	addl	a6@(PRGHDR_BLEN),d7
	addl	__stksize,d7		/* length of text+data+BSS+stack */
	movl	d7,__PgmSize
	
	movl	d7,sp@-			/* new size of block */
	movl	a5,sp@-			/* base address */
	clrw	sp@-			/* dummy arg */
	movw	#74,sp@-
	trap	#1			/* Mshrink() */
	addw	#12,sp

	/* Create a dummy basepage in the 512 bytes before our code
	 * (where the map sector was). We run the loader as a separate
	 * process so that all allocated memory will be cleaned up
	 * after it finishes. We can't use Pexec(5) for this, because
	 * this allocates the biggest free memory block and an
	 * environment.
	 */
	movl	a5,a5@(BP_LOWTPA)
	lea	a5@(d7:l),a0
	movl	a0,a5@(BP_HITPA)
	movl	#pgm_start,a5@(BP_TBASE)/* that's what Pexec(4) will jump to */
	/* tlen, dbase, ..., blen need not be initialized */
	lea	a5@(BP_CMDLIN),a0
	movl	a0,a5@(BP_DTA)
	movl	_sysbase,a0
	movl	a0@(40),a0		/* a0 == p_actpd (p_run) */
	movl	a0@,a0			/* a0 = *p_actpd = actpd */
	movl	a0,a5@(BP_PARENT)	/* put in current process BP */
	movl	#1,a5@(BP_FLAGS)	/* set fastload flag, but not fastram
					 * flags (better use ST-RAM for
					 * DMAread!) */
	movl	#dummy_env,a5@(BP_ENV)

/* Output another 'o' to indicate that the Mshrink is done and the basepage
 * has been set up */
	moveq	#'o',d0
	jbsr	putc

	clrl	sp@-
	movl	a5,sp@-
	clrl	sp@-
	movw	#4,sp@-
	movw	#75,sp@-
	trap	#1			/* Pexec(4,NULL,__base,NULL) */
	addw	#16,sp

	/* If the Pexec() returns, the loader process has called Pterm.
	 * Free the memory and decide from _ExitAction what to do.
	 */
	movl	__base,sp@-
	movw	#0x49,sp@-	
	trap	#1        /* Mfree(_base), free the loader's TPA */
	addql	#6,sp

	movl	_ExitAction,d0
	cmpl	#1,d0
	bne	1f
/* exit_action == 1: jump back to ROM by doing rts. Hopyfully the hd
 * driver is installed now. */
	movml	sp@+,d0-d7/a0-a6 /* pop registers saved by rootsect.S */
	movw	#0xe0,d7 /* for old TOS versions, end boot-try loop (shouldn't
	                  * be necessary, but anyway... */
	rts

1:	cmpl	#2,d0
	bne	1f
/* exit_action == 2: jump to *dskbuf (bootsector) */
	movml	sp@+,d0-d7/a0-a6 /* pop registers saved by rootsect.S */
	/* I don't think we have to set up any register in a special way here,
	 * right? */
	movl	0x4c6,sp@-
	rts

/* default _exit action: print message and halt */
1:	movl	#halt_text,sp@-
	movw	#9,sp@-
	trap	#1			/* Cconws */
	addql	#6,sp	
endless:
	bra	endless
	
		
/*
 * Here's the start of the sub-process. We don't need to Mshrink() our memory
 * (that's already done), and we don't need to change the stack (it's now at
 * the end of the TPA, and that end is the end of our Malloc()ed area, which
 * is fine.)
 */

pgm_start:
/* Output a 't' to indicate that we're in the subprocess */
	moveq	#'t',d0
	jbsr	putc

	/* Initialize some library variables */
	moveq	#1,d0
	movw	d0,__app
	movw	d0,__split_mem
	clrl	__heapbase
	tstl	___DEFAULT_BUFSIZ__
	jbne	1f
	movl	#BUFSIZ,___DEFAULT_BUFSIZ__
1:	
	jbsr	__init_signal
	
/* Output a 'e' to indicate that we're about to call _main(); there, the final
 * 'd' will be printed */
	moveq	#'e',d0
	jbsr	putc

	/* now jump to _main; simply give it no args and no environment */
1:	pea	dummy_env
	pea	arg_array
	movl	#1,sp@-
	jbsr	__main
	movl	d0,sp@-
	jbsr	_exit

/* We must supply _exit, otherwise the real crtinit.o from mint.olb is pulled
 * in */
	.globl	__exit
__exit:
	tstl	sp@+			/* pop return address */
	movl	sp@+,d0			/* exit status */
	movw	d0,sp@-			/* push status as 16 bit */
	movw	#76,sp@-
	trap	#1			/* Pterm() */

		
/* Just for debugging: print a character in %d0; no clobbered registers */
putc:
	movml	d0-d2/a0-a2,sp@-
	movw	d0,sp@-
	movw	#2,sp@-
	trap	#1			/* Cconout */
	addql	#4,sp
	movml	sp@+,d0-d2/a0-a2
	rts
	

/* Local Variables:			*/
/*   tab-width:	8			*/
/*   fill-column: 78			*/
/*   asm-comment-char: ?|		*/
/* End:					*/
